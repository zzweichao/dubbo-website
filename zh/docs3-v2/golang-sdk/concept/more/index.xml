<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – 更多</title><link>https://dubbo.apache.org/zh/docs3-v2/golang-sdk/concept/more/</link><description>Recent content in 更多 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dubbo.apache.org/zh/docs3-v2/golang-sdk/concept/more/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs3-V2: dubbo-go 3.0 新特性</title><link>https://dubbo.apache.org/zh/docs3-v2/golang-sdk/concept/more/3.0_feature/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs3-v2/golang-sdk/concept/more/3.0_feature/</guid><description>
&lt;p>&lt;img src="https://shields.io/github/stars/apache/dubbo-go?style=dark" alt="star">&lt;/p>
&lt;h2 id="1-triple-协议">1. Triple 协议&lt;/h2>
&lt;h3 id="11-概述">1.1 概述&lt;/h3>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/docs3-v2/golang-sdk/concept/more/3.0_feature/tri.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通信层面&lt;/p>
&lt;p>Triple 协议，也称为Dubbo3协议，是基于HTTP2 + gRPC协议，增加特定字段和逻辑的扩展协议，保证了和&lt;strong>原生gRPC协议互通&lt;/strong>。在此基础之上，Triple 新协议将更原生地支持 &lt;strong>Dubbo 服务治理能力&lt;/strong>。并支持&lt;strong>流式RPC调用&lt;/strong>。&lt;/p>
&lt;p>简单来说，可以理解为 Triple = gRPC + Dubbo&lt;/p>
&lt;/li>
&lt;li>
&lt;p>序列化&lt;/p>
&lt;p>Triple 协议使用高效的&lt;strong>PB序列化方式&lt;/strong>，并在此基础之上增加序列化协议的&lt;strong>可扩展支持&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户开发习惯：&lt;/p>
&lt;p>Triple 服务在开发前需要&lt;strong>预定义.proto文件&lt;/strong>，对于习惯在编码前先定义IDL的Go语言开发者带来便捷。不同于符合java编程习惯的，定义JavaClassName用于描述接口的 Dubbo-go 1.x版本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>跨语言互通性：&lt;/p>
&lt;p>可与 Dubbo-Java 实现&lt;strong>跨语言互通&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="2-应用级服务发现">2. 应用级服务发现&lt;/h2>
&lt;h3 id="21-简介">2.1 简介&lt;/h3>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/docs3-v2/golang-sdk/concept/more/3.0_feature/disc.png" alt="">&lt;/p>
&lt;p>在服务注册阶段，服务端实例将应用级别的注册信息，主要包含从应用名到实例IP的映射注册到注册中心。在服务发现阶段，客户端实例，通过注册中心获取到需要请求的服务实例IP。进入服务自省阶段，服务自省过程为通过应用信息获取接口信息的过程。如上图，包含两种模式：&lt;/p>
&lt;ol>
&lt;li>remote模式：通过元数据中心（例如 zk ）获取应用到接口元数据的映射&lt;/li>
&lt;li>local模式：直接通过服务端获取应用到接口元数据的映射（通过 Dubbo 协议针对 Metadata Service 发起 RPC 调用）&lt;/li>
&lt;/ol>
&lt;p>经过服务自省后，客户端正式向对应实例发起调用。这样做最明显的好处是减少了注册中心的数据量，即注册中心只保存了应用级别的数据。&lt;/p>
&lt;p>用户在使用 Dubbo-go 3.0的应用级服务发现能力时，可以仿照示例，直接在配置文件中配置服务自省模式和元数据中心信息，引入依赖，开启应用级别服务发现。&lt;/p>
&lt;h3 id="22-应用级服务发现介绍文章">2.2 应用级服务发现介绍文章&lt;/h3>
&lt;p>&lt;a href="https://baijiahao.baidu.com/s?id=1669266413887039723&amp;amp;wfr=spider&amp;amp;for=pc">应用级服务发现解析&lt;/a>&lt;/p>
&lt;h2 id="3-mesh-路由规则">3. Mesh 路由规则&lt;/h2>
&lt;p>用户可定义路由文件：&lt;/p>
&lt;p>virtual_service.yaml&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/docs3-v2/golang-sdk/concept/more/3.0_feature/virtual_service.png" alt="">&lt;/p>
&lt;p>以及 dist_rule.yml&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/docs3-v2/golang-sdk/concept/more/3.0_feature/dest_rule.png" alt="">&lt;/p>
&lt;p>框架可根据路由文件针对特定的请求进行流量转发。&lt;/p>
&lt;h2 id="4-相关文章">4. 相关文章&lt;/h2>
&lt;p>阿里云官方介绍文章：&lt;a href="https://developer.aliyun.com/article/770964?utm_content=g_1000175535">《Dubbo 3.0 - 开启下一代云原生微服务》&lt;/a>&lt;/p></description></item><item><title>Docs3-V2: Dubbo的应用和接口</title><link>https://dubbo.apache.org/zh/docs3-v2/golang-sdk/concept/more/app_and_interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs3-v2/golang-sdk/concept/more/app_and_interface/</guid><description>
&lt;h2 id="dubbogo-服务层级">Dubbogo 服务层级&lt;/h2>
&lt;p>Dubbogo 服务层级为两个级别：分别是应用级别(App Level)和接口级别(Interface Level)，该服务分层与&lt;strong>框架配置&lt;/strong>结构息息相关。&lt;/p>
&lt;p>如下图所示，可以看到，应用级别的组件以浅红色标注，接口级别的组件以浅蓝色标注：&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/docs3-v2/golang-sdk/concept/more/app_and_interface/dubbogo-concept.png" alt="">&lt;/p>
&lt;h2 id="1-应用级别组件">1. 应用级别组件&lt;/h2>
&lt;p>应用级别组件的特点：被当前应用的所有接口级别组件共用。&lt;/p>
&lt;p>应用级别的主要组件如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>应用信息模块&lt;/p>
&lt;p>包含应用维度相关信息，包括应用名、版本号、数据上报方式等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Consumer 模块&lt;/p>
&lt;p>Consumer 模块负责客户端相关信息，包括一个或多个引用（Reference）结构，以及超时、客户端过滤器（consumer filter）等相关信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Provider 模块&lt;/p>
&lt;p>Provider 模块负责服务端相关信息，包括一个或多个服务（Service）结构、服务端过滤器（provider filter）等相关信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注册中心（Registry）模块&lt;/p>
&lt;p>注册中心模块负责定义好所要使用的一系列注册中心，例如框架支持的ZK、Nacos、ETCD等中间件。应用级别的注册模块只负责声明，由接口级别的组件进行引用，引用时以用户自定义的注册中心ID（registryID) 作为索引。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>协议（Protocol）模块&lt;/p>
&lt;p>协议模块只存在于服务端。&lt;/p>
&lt;p>协议模块关心服务的暴露信息，例如协议名、服务监听IP、端口号等信息。协议模块属于应用级别，只负责声明，由接口级别的组件进行引用，引用时以用户自定义的协议ID（protocolID) 作为索引。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>元数据中心模块&lt;/p>
&lt;p>元数据中心类似于注册中心模块，负责声明框架需要使用的元数据中心，从而将元数据成功上报。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置中心模块&lt;/p>
&lt;/li>
&lt;li>
&lt;p>路由模块&lt;/p>
&lt;/li>
&lt;li>
&lt;p>日志模块&lt;/p>
&lt;/li>
&lt;li>
&lt;p>监控模块&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="2-接口级别组件">2. 接口级别组件&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>服务（Service）模块&lt;/p>
&lt;p>服务模块被使用于任何暴露的服务，声明接口暴露所需的信息，包括例如接口名、协议、序列化方式等，负责单个服务接口的暴露。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引用（Reference）模块&lt;/p>
&lt;p>饮用模块被使用于需要调用的远程服务的客户端，其声明了需要请求接口所需的信息，包括例如接口名、协议、序列化方式等、负责特定协议的抽象，参与客户端的生成。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="3-说明">3. 说明&lt;/h2>
&lt;p>暴露的服务是接口级别的，一个用户定义的 Provider Struct/一个用户定义的Consumer Struct，对应一个Service/Reference 模块，一个应用可以同时存在Consumer 模块和 Provider 模块，因此可以同时存在多个Service/Reference 模块。&lt;/p></description></item><item><title>Docs3-V2: 架构</title><link>https://dubbo.apache.org/zh/docs3-v2/golang-sdk/concept/more/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh/docs3-v2/golang-sdk/concept/more/architecture/</guid><description>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/docs3-v2/golang-sdk/concept/more/architecture/architecture.png" alt="architecture">&lt;/p>
&lt;h4 id="节点说明">节点说明&lt;/h4>
&lt;ul>
&lt;li>&lt;code>Registry&lt;/code> : dubbo-go中负责服务注册与发现的注册中心&lt;/li>
&lt;li>&lt;code>Consumer&lt;/code> : 调用远程服务的服务消费方&lt;/li>
&lt;li>&lt;code>Provider&lt;/code> : 暴露服务的服务提供方&lt;/li>
&lt;/ul>
&lt;h4 id="过程说明">过程说明&lt;/h4>
&lt;ul>
&lt;li>&lt;code>0. register&lt;/code> : 当服务提供方在启动的时候，会自动将自己的服务注册到注册中心&lt;/li>
&lt;li>&lt;code>1. subscribe&lt;/code> : 服务消费方会在启动的时候，向注册中心订阅自己所需要的服务&lt;/li>
&lt;li>&lt;code>2. notify&lt;/code> : 注册中心返回服务注册的信息给到服务消费方，当订阅的服务发生变更，会推送变更的数据给到消费方&lt;/li>
&lt;li>&lt;code>3. invoke&lt;/code> : 服务消费者根据从注册中心获得的服务地址，经过负载均衡算法选出一个合适的服务地址发起请求&lt;/li>
&lt;/ul></description></item></channel></rss>